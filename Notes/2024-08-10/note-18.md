## 不要读源码 Why

任何人问我要不要读原版 我都一定会回答不要 因为 如果一个人问的是要不要读源码而非如何读的话，说明他自己都不知道读圆满能带来什么，更多的是一种人云亦云似的觉着源码很好，很有价值，所以应该读 在这种情况下 读源码其实是很危险的 一个也许超乎人大多数意料的事实是，读源码并不是一种很好的学习行为

首先是如果不知道为什么 源码就别 因为本身读源码并不是一个很好的实践学习方案 就跟我们学解数学题的时候应该学的是解题思路 而不是背答案一样 知道怎么把答案写出来的思考过程更关键

其次是即使知道了，也要确定这个目的是否合理，有没有更好的解决方案 比如什么框架或者工具库 如果我们不是开发这些工具 那就没必要学  产品和工具是两类应用 图他们的策略是不一样的 通常来说 尤其是了解框架工具的写法最不必要的 因为绝大多数人不会真正开发一个框架 但多数人都需要实现产品应用 所以当你以后读框架的时候 一定要谨慎 到底是因为你想开发框架所以学习，还是你想用它再学习 实惠人需要通过阅读框架源码来学习，使用框架就通常说明他不是一个很好的项目 接口的抽象定义的是有问题的 因而也很难说是一个好的学习对象

首先是如果不知道为什么 源码就别 因为本身读源码并不是一个很好的实践学习方案 就跟我们学解数学题的时候应该学的是解题思路 而不是背答案一样 知道怎么把答案写出来的思考过程更关键

其实读圆满不是一种学习最高的、学习效率最高的方式 因为代码本质上是思考得出的结论 而不是人思考的过程 它就像是数学题中直接写出来的答案 还是那个问题，我们即使知道了这个场景下他是这样写的，但如果知道推导的过程，我们还是再换一个场景下，不能想象为什么他要写成那样，而不是这样

所以 在某些程度上 其实读源码是一种很低效率的行为

## 为什么要读 目的、价值是什么 如何找到适合自己的好代码

但又说回来了 读源码又还是很必要的 它也许是人提升品味的必要路径 这里的原因是 虽然理论上有更好的学习写代码的方法 但凭什么那些掌握这些能力的大佬教我们的 代码品味更像是一个美学似的东西 他并不太容易被用一个教科书来解释明白 同时，一般大佬都有着自己的本职工作，他们也很少去真正做教书这件事
所以，去读那些大佬们的代码，可能是我们的真正可行解中相对来说较好的一种方案 虽然这个过程会比较痛苦 有时候不能理解他们思想 确实容易一筹莫展 但可能确实是研发成长的必经之路
说回来了 毕竟编码有时候也是一种美学 而艺术类的东西是需要通过大量的审美与审 不断见到好的代码与烂的代码，经过比较才能认识到提升自己的品位 进而提升自己的编码能力的 那学习大佬的代码哪怕是东施效颦 也能整照猫画虎的 维持住自己代码的基础底线 在随着自己编码经历的不断加深，逐步的理解他们的完整设计意义
这些我们之前阅读的源码，就像是一个个种在我们心里的种子 在最早，我们可能不理解他们为什么要设计如此复杂的结构 但真正遇到了一些场景，让我们发现还是他们这种模式最好，避无可避的时候 那些之前种下的种子就会发芽成长

对于阅读圆满而言 最重要的一点
确认自己有没有必要越读越
你的目的是什么
这个目的要足够的精确，而不能是一个口号，不是别人给你宣贯出来的一个理念
不能是我觉得读源码很有必要 所以我要学
你要有一个可以衡量的结果 切实解决的目的
举个例子，我想要学习一门新语言，或者说我只掌握了语言的语法，所以要了解他一些更深入的工程实践
还是我想了解一个领域的项目该如何开发，所以借鉴一些已有的成型项目
亦或者是某个应用本身做得很好，我想给他添加一些功能，所以要理解代码
再者还是我们依赖某个框架 需要阅读源码来方便我们使用 这个其实很危险 因为如果一个框架需要使用者阅读源码才能高效使用的话，其实说明它的抽象设计是有问题的 这是一个不太好的项目 可能更好的策略是不要选 当然 有时候我们也不可避免
如果是要应付面试的话 那坦白说 多看看8股的效果 要比真老是看代码强 这其实是一个过拟合的问题 大多数面试官也不会很认真的去看那些内容 大家也就是网上抄一些面经的题 互相看看 不如直接上网背答案 而不是去看教科书 其实有点像高考了

其次是即使知道了，也要确定这个目的是否合理，有没有更好的解决方案 比如什么框架或者工具库 如果我们不是开发这些工具 那就没必要学  产品和工具是两类应用 图他们的策略是不一样的 通常来说 尤其是了解框架工具的写法最不必要的 因为绝大多数人不会真正开发一个框架 但多数人都需要实现产品应用 所以当你以后读框架的时候 一定要谨慎 到底是因为你想开发框架所以学习，还是你想用它再学习 实惠人需要通过阅读框架源码来学习，使用框架就通常说明他不是一个很好的项目 接口的抽象定义的是有问题的 因而也很难说是一个好的学习对象

在有了这些目标后 我们才应该去研究如何去呀

有具体动机的意愿才是意愿 如果我们只是有一种宏观的我想读圆满 那他是不足以推动驱使我们完成工作的 因为它不够具体 没有可执行性 只是一句口号
我们讲究宁缺毋滥 即使单着也不能随便霍霍别人 对大家都是一种伤害
真正能推动我们读源码的 一定是一个具体的目的 这个目的可以根据个人原因自己定义 但他一定能推出我们的行动
具体有几种类型
想要了解一个产品型应用的在吗 那就要搞明白，我们到底是要提升产品设计能力，还是真正的架构
有几种误区
首先是想为了学习一门语言去读源码 这个问题错在了学语言本身就是一个很抽象的命题
其次是学习框架的源码来理解框架使用 前提一定是已经把框架本身都掌握的非常熟练了 有非常确实的需求

但同时其实社区的这些代码多有不足，所以我们很容易的思路能做一些小球修改

最终是一些具体的手段 原则是从简单的项目入手 这样至少我们可以读整个项目来保证对源码的理解 大项目困难之处在于，没法儿一下儿完整理解整个项目 只能基于自己的猜测 完成大块儿的内容的定义 然后去实现一些局部的部分 相当于很多逻辑是我们脑补的 而不是真实存在的 猜测正确与否 就很依赖我们的经验了 当然一方面如果有一些文档或者是文章的说明也很适合我们先补充一些大概的思路 在此之后 在切入项目中 才是更好的策略

当然 足圆满还是要有目的 最好我们要能做一些产出 而不是只是读完看着理解 因为项目不运行，我们无法真正验证自己的思考正确与否 同时也不确定我们的理解是否正确 如果有项目维护者的review，能帮助我们确定我们自己的理解正确与否 本质还是尽可能不靠源码来理解项目

首先要明确自己的目的 如果是那些很学术性的学科知识 那通常来说 拿一本教科书来学习更好 一些高质量的书籍都配有相关的仓库 嗯 不需要额外的去寻找代码 当然，有一些大佬的笔记也会做成仓库来发布，这也是可以学习的
如果是一些工程上的编程能力练习 首先要确定的是 这些仓库本身质量一定要好 不能天天学点坏东西

几个判断的方法

最首先 如果有一项你经常使用的工具应用 是开源 并且是你想要了解的语言 那他是再好不过了
先看最近更新频率 通常 尤其是一些网红语 如果时间早个三五年，可能写法完全不一样，甚至落后的
首先最明显的就是大数先要看star的数量 另外一个关键因素是 是否是大厂还是个人项目 通常大厂的项目有基础的文档。更加
另外也要看文档的质量 如果项目都没有什么。Read me 那我们也很难把项目启动起来

## 如何读源码

最终是一些具体的手段 原则是从简单的项目入手 这样至少我们可以读整个项目来保证对源码的理解 大项目困难之处在于，没法儿一下儿完整理解整个项目 只能基于自己的猜测 完成大块儿的内容的定义 然后去实现一些局部的部分 相当于很多逻辑是我们脑补的 而不是真实存在的 猜测正确与否 就很依赖我们的经验了 当然一方面如果有一些文档或者是文章的说明也很适合我们先补充一些大概的思路 在此之后 在切入项目中 才是更好的策略

当然，在此之前，最好还是拿额外的信息，比如看一些相关的PR或者医学 如果我们有意 那首先发现一些我们想要改进的功能 然后去搜一下社区有没有相关的实现和讨论 其实最好的反而是那些已经被实现的能力 因为讨论过程更完整 而且有一个实现的结论 我们在最早入门的时候不太需要对项目有个太具体的把握，也能通过这个MR验证跟自己的差别 确认自己的思路正确
但同时，其实社区的PR也是一种follow的机会 因为受限于他们的理解不足 实现功能不一定非常完善 这就让我们在后续的小修小补中提供了机会

然后最重要的就是把项目运行 在运行后才应该调试 相当于验证我们的模型是否正确
当然，在此之前，最好还是拿额外的信息，比如看一些相关的PR或者医学 如果我们有意 那首先发现一些我们想要改进的功能 然后去搜一下社区有没有相关的实现和讨论 其实最好的反而是那些已经被实现的能力 因为讨论过程更完整 而且有一个实现的结论 我们在最早入门的时候不太需要对项目有个太具体的把握，也能通过这个MR验证跟自己的差别 确认自己的思路正确

当然 足圆满还是要有目的 最好我们要能做一些产出 而不是只是读完看着理解 因为项目不运行，我们无法真正验证自己的思考正确与否 同时也不确定我们的理解是否正确 如果有项目维护者的review，能帮助我们确定我们自己的理解正确与否 本质还是尽可能不靠源码来理解项目
然后最重要的就是把项目运行 在运行后才应该调试 相当于验证我们的模型是否正确

然后就是在国内的社区找有没有相关的源码解读 事实上 确实，国内很流行读源码的风气，那有一些前人的基础，我们就更容易上手 这一步主要是对整个项目的架构有所认识

再之后就是运行起来 项目 单看源码跟运行项目有什么区别呢 一个关键的点就是他为你通过改造代码验证想法产生的机会 我们首先要能打上断点或者调试功能，才能验证自己对代码的理解，不然的话，哪怕错了也不知道 这不就跟我们写代码的初衷发生了偏离
其次是要拿我们上面的需求去找切入点 一般复杂的项目都不是类似脚本的顺序执行逻辑 很多功能都是在图状的结构拥有不同的切面 那我们没很难通过顺序阅读幂函数来理解项目 或者说，即使理解了主函数，也不太能理解功能是如何生效的 坦率说 加载逻辑不宜在最开始追纠结过程 因为这一部分是副作用最多的环节 嗯 我们只要保证能跑起来就好

然后就是找到一些词的功能 开始修修改改 比如我们改Vs code 结合自己的需求 我们的诉求是想要提升
一个很好的切入手段是发现需求 最好是那些社区已经完成修复 有一秀讨论以及PR合并的内容 因为这些内容一般相对简单 社区的贡献还是处于表层的位置，就降低了我们理解的难度 另外 整体的讨论流程也非常丰富 能帮助我们快速理解上下文 很多时候 这些大厂的工作流并不完全在给他 他们的信息差 会让我们理解内容很困难 还有一个额外的小优势是 社区的代码未必会考虑完整的case 他们都是解决自己的问题 那我们沿着他的思考路径来看 就容易发现一些额外的小问题来辅助修正 成本很低 但是也确实解决问题

## 实践 -- 简单修改 VSCode 代码

那先拿一个真实的例子来说，就是修改v s code代码那首先 我们要想的是我们有什么确切的需求需要解决sn拿我自己来说 ，我会经常在。 s code里边记笔记。 但是中文笔记有一个巨大的痛点是 当我使用 alt加左右键跳转时，它会如这样所示一下跳转一整个句子而并不是像英文一样跳转若干单词 sn。 那这就对我的 文章修改过程造成了非常大的不便 基本上是不可用的状态 那我 第一的想法，就是去看 
我是一个高频使用 VSCode 记录 Markdown 笔记的人. 进行中文写作时, 我最大的痛点是: VSCode 单词跳转功能的使用体验不佳 (快捷键 Alt + ArrowLeft 及 Alt + ArrowRight 对应的 cursorWordLeft 与 cursorWordRight 命令). 受限于 VSCode 基于空格的分词策略, 中文的一整段话被视为了一个单词. 更糟糕的是, 由于汉字标点符号并非 ascii 字符, 所以跳转甚至都不是基于一句而是一整段话. 按一下上述快捷键, 一整段话就会跳过去, 每每碰到这一点都让人感到恼火.

所以之前我采用的是 这个插件 来实现分词跳转的能力, 可以说其功能还是相对全面的. 唯二的缺憾是, 受 VSCode 的插件 API 限制, 插件并不能实现鼠标双击仅选择当前 Token 的能力. 另外, 插件毕竟还是对整个应用性能有一丁点的拖累, 心中稍有一丝不爽.

但今天早上起床之后, 我突然灵光一闪: 这个插件下载量只有一万多次, 但使用 VSCode 写 Markdown 的中日文用户一定不只是这一点, 那么多中国人、日本人或者其他有类似语言的国家的人, 一定都非常苦恼于这个场景的糟糕体验, 那为什么不去搜搜 VSCode 官方是否有成熟的解决方案呢? 一看还真有, Issue 50045 就完美地描述了这个需求, 但毕竟 VSCode 的核心开发者都是欧美国家的人, 对他们而言恐怕都想象不到这到底是一个什么样子的 case. 为了完成一个需求要再学一门架构与先前掌握语言比完全不同的自然语言, 实在是有些夸张了.

好在我又注意到这个 Issue 已经被关闭了. 既然 Issue 是长期存在的需求, 而并非偶现的 Bug, 那这大概率是说明有人已经完成了这个功能的开发. 再往下翻一番, 果然如此: 一位日本友人发起的 PR 203605 关闭了该需求. 又发现这个 PR 是今年年初才发起, 这也解释了为什么我之前只搜到了上述插件, 而并非是这个原生功能.

从需求提出 (2018-05) 到需求解决 (2024-01), 中间经历了快六年的时间, 让人不禁感慨: i18n 实在是太难了!

但这其实未必结束 ，因为这些社区贡献的代码受限于提交者自己的理解限制，他们未必能完美的把这个需求做完在其中还是有一些可以小修小补的地方，这就是我们继续为项目进行贡献的机会和入手的一些点 就拿这个项目为例 作者只实现了在editor里面的 中文条或者说，文字跳转 但比如我们在 一些特殊的simple editor里比如 chat view或者是。 s m auditor，这些领域 并没有同样的实现跳转的效果 这说明 其功能还是漏了一些东西 ，那我们就恰好可以以此为入手来分析为什么它丢了一些内容 那当然，我们最好还是把项目启动起来看一下这些内容中为什么没有生效 嗯首先一个思路是review他的 m r 因为这段代码肯定是核心业务逻辑，我们可以先在项目中找到这些内容来分析到底它出现。 哪些问题导致还不可用 

参考链接
https://sharzy.in/posts/2020-02-04-cjk-helper/
https://github.com/microsoft/vscode/pull/203605
https://github.com/microsoft/vs